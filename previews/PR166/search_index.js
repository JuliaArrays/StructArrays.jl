var documenterSearchIndex = {"docs":
[{"location":"#StructArrays.jl","page":"StructArrays.jl","title":"StructArrays.jl","text":"","category":"section"},{"location":"","page":"StructArrays.jl","title":"StructArrays.jl","text":"CurrentModule = StructArrays","category":"page"},{"location":"#Type","page":"StructArrays.jl","title":"Type","text":"","category":"section"},{"location":"","page":"StructArrays.jl","title":"StructArrays.jl","text":"StructArray","category":"page"},{"location":"#StructArrays.StructArray","page":"StructArrays.jl","title":"StructArrays.StructArray","text":"StructArray{T,N,C,I} <: AbstractArray{T, N}\n\nA type that stores an N-dimensional array of structures of type T as a structure of arrays.\n\ngetindex and setindex! are overloaded to get/set values of type T.\ngetproperty is overloaded to return individual field arrays.\n\nFields\n\nfieldarrays: a NamedTuple or Tuple of the arrays used by each field. These can be accessed by fieldarrays(x).\n\n\n\n\n\n","category":"type"},{"location":"#Constructors","page":"StructArrays.jl","title":"Constructors","text":"","category":"section"},{"location":"","page":"StructArrays.jl","title":"StructArrays.jl","text":"StructArray(tup::Union{Tuple,NamedTuple})\nStructArray(::Base.UndefInitializer, sz::Dims)\nStructArray(v)\ncollect_structarray","category":"page"},{"location":"#StructArrays.StructArray-Tuple{Union{Tuple, NamedTuple}}","page":"StructArrays.jl","title":"StructArrays.StructArray","text":"StructArray{T}((fieldarrays...)::Union{Tuple, NamedTuple})\nStructArray{T}(name1=fieldarray1, name2=fieldarray2, ...)\n\nConstruct a StructArray of element type T from the specified field arrays.\n\nStructArray((fieldarrays...)::Union{Tuple, NamedTuple})\nStructArray(name1=fieldarray1, name2=fieldarray2, ...)\n\nConstruct a StructArray with a Tuple or NamedTuple element type from the specified field arrays.\n\nExamples\n\njulia> StructArray{ComplexF64}(([1.0, 2.0], [3.0, 4.0]))\n2-element StructArray(::Array{Float64,1}, ::Array{Float64,1}) with eltype Complex{Float64}:\n 1.0 + 3.0im\n 2.0 + 4.0im\n\njulia> StructArray{ComplexF64}(re=[1.0, 2.0], im=[3.0, 4.0])\n2-element StructArray(::Array{Float64,1}, ::Array{Float64,1}) with eltype Complex{Float64}:\n 1.0 + 3.0im\n 2.0 + 4.0im\n\nAny AbstractArray can be used as a field array\n\njulia> StructArray{Complex{Int64}}(([1, 2], 3:4))\n2-element StructArray(::Array{Int64,1}, ::UnitRange{Int64}) with eltype Complex{Int64}:\n 1 + 3im\n 2 + 4im\n\nIf no element type T is provided, a Tuple or NamedTuple is used:\n\njulia> StructArray((zeros(2,2), ones(2,2)))\n2×2 StructArray(::Array{Float64,2}, ::Array{Float64,2}) with eltype Tuple{Float64,Float64}:\n (0.0, 1.0)  (0.0, 1.0)\n (0.0, 1.0)  (0.0, 1.0)\n\njulia> StructArray(a=zeros(2,2), b=ones(2,2))\n2×2 StructArray(::Array{Float64,2}, ::Array{Float64,2}) with eltype NamedTuple{(:a, :b),Tuple{Float64,Float64}}:\n (a = 0.0, b = 1.0)  (a = 0.0, b = 1.0)\n (a = 0.0, b = 1.0)  (a = 0.0, b = 1.0)\n\n\n\n\n\n","category":"method"},{"location":"#StructArrays.StructArray-Tuple{UndefInitializer,Tuple{Vararg{Int64,N}} where N}","page":"StructArrays.jl","title":"StructArrays.StructArray","text":"StructArray{T}(undef, dims; unwrap=T->false)\n\nConstruct an uninitialized StructArray with element type T, with Array field arrays.\n\nThe unwrap keyword argument is a function that determines whether to recursively convert arrays of element type T to StructArrays.\n\nExamples\n\njulia> StructArray{ComplexF64}(undef, (2,3))\n2×3 StructArray(::Array{Float64,2}, ::Array{Float64,2}) with eltype Complex{Float64}:\n  2.3166e-314+2.38405e-314im  2.39849e-314+2.38405e-314im  2.41529e-314+2.38405e-314im\n 2.31596e-314+2.41529e-314im  2.31596e-314+2.41529e-314im  2.31596e-314+NaN*im\n\n\n\n\n\n","category":"method"},{"location":"#StructArrays.StructArray-Tuple{Any}","page":"StructArrays.jl","title":"StructArrays.StructArray","text":"StructArray(A; unwrap = T->false)\n\nConstruct a StructArray from an existing multidimensional array or iterator A.\n\nThe unwrap keyword argument is a function that determines whether to recursively convert arrays of element type T to StructArrays.\n\nExamples\n\nBasic usage\n\njulia> A = rand(ComplexF32, 2,2)\n2×2 Array{Complex{Float32},2}:\n 0.694399+0.94999im  0.422804+0.891131im\n 0.101001+0.33644im  0.632468+0.811319im\n\njulia> StructArray(A)\n2×2 StructArray(::Array{Float32,2}, ::Array{Float32,2}) with eltype Complex{Float32}:\n 0.694399+0.94999im  0.422804+0.891131im\n 0.101001+0.33644im  0.632468+0.811319im\n\nFrom an iterator\n\njulia> StructArray((1, Complex(i, j)) for i = 1:3, j = 2:4)\n3×3 StructArray(::Array{Int64,2}, ::Array{Complex{Int64},2}) with eltype Tuple{Int64,Complex{Int64}}:\n (1, 1+2im)  (1, 1+3im)  (1, 1+4im)\n (1, 2+2im)  (1, 2+3im)  (1, 2+4im)\n (1, 3+2im)  (1, 3+3im)  (1, 3+4im)\n\nRecursive unwrapping\n\njulia> StructArray((1, Complex(i, j)) for i = 1:3, j = 2:4; unwrap = T -> !(T<:Real))\n3×3 StructArray(::Array{Int64,2}, StructArray(::Array{Int64,2}, ::Array{Int64,2})) with eltype Tuple{Int64,Complex{Int64}}:\n (1, 1+2im)  (1, 1+3im)  (1, 1+4im)\n (1, 2+2im)  (1, 2+3im)  (1, 2+4im)\n (1, 3+2im)  (1, 3+3im)  (1, 3+4im)\n\n\n\n\n\n","category":"method"},{"location":"#StructArrays.collect_structarray","page":"StructArrays.jl","title":"StructArrays.collect_structarray","text":"collect_structarray(itr; initializer = default_initializer)\n\nCollects itr into a StructArray. The user can optionally pass a initializer, that is to say a function (S, d) -> v that associates to a type and a size an array of eltype S and size d. By default initializer returns a StructArray of Array but custom array types may be used.\n\n\n\n\n\n","category":"function"},{"location":"#Accessors","page":"StructArrays.jl","title":"Accessors","text":"","category":"section"},{"location":"","page":"StructArrays.jl","title":"StructArrays.jl","text":"fieldarrays","category":"page"},{"location":"#StructArrays.fieldarrays","page":"StructArrays.jl","title":"StructArrays.fieldarrays","text":"fieldarrays(s::StructArray)\n\nReturn the field arrays corresponding to the various entry of the struct as a NamedTuple, or a Tuple if the struct has no names.\n\nExamples\n\njulia> s = StructArray(rand(ComplexF64, 4));\n\njulia> fieldarrays(s)\n(re = [0.396526, 0.486036, 0.459595, 0.0323561], im = [0.147702, 0.81043, 0.00993469, 0.487091])\n\n\n\n\n\n","category":"function"},{"location":"#Lazy-iteration","page":"StructArrays.jl","title":"Lazy iteration","text":"","category":"section"},{"location":"","page":"StructArrays.jl","title":"StructArrays.jl","text":"LazyRow\nLazyRows","category":"page"},{"location":"#StructArrays.LazyRow","page":"StructArrays.jl","title":"StructArrays.LazyRow","text":"LazyRow(s::StructArray, i)\n\nA lazy representation of s[i]. LazyRow(s, i) does not materialize the ith row but returns a lazy wrapper around it on which getproperty does the correct thing. This is useful when the row has many fields only some of which are necessary. It also allows changing columns in place.\n\nSee LazyRows to get an iterator of LazyRows.\n\nExamples\n\njulia> t = StructArray((a = [1, 2], b = [\"x\", \"y\"]));\n\njulia> LazyRow(t, 2).a\n2\n\njulia> LazyRow(t, 2).a = 123\n123\n\njulia> t\n2-element StructArray(::Array{Int64,1}, ::Array{String,1}) with eltype NamedTuple{(:a, :b),Tuple{Int64,String}}:\n (a = 1, b = \"x\")\n (a = 123, b = \"y\")\n\n\n\n\n\n","category":"type"},{"location":"#StructArrays.LazyRows","page":"StructArrays.jl","title":"StructArrays.LazyRows","text":"LazyRows(s::StructArray)\n\nAn iterator of LazyRows of s.\n\nExamples\n\njulia> map(t -> t.b ^ t.a, LazyRows(t))\n2-element Array{String,1}:\n \"x\"\n \"yy\"\n\n\n\n\n\n","category":"type"},{"location":"#Advanced-APIs","page":"StructArrays.jl","title":"Advanced APIs","text":"","category":"section"},{"location":"","page":"StructArrays.jl","title":"StructArrays.jl","text":"StructArrays.append!!\nStructArrays.replace_storage\nStructArrays.staticschema\nStructArrays.createinstance","category":"page"},{"location":"#StructArrays.append!!","page":"StructArrays.jl","title":"StructArrays.append!!","text":"dest = StructArrays.append!!(dest, itr)\n\nTry to append itr into a vector dest, widening the element type of dest if it cannot hold the elements of itr. That is to say,\n\nvcat(dest, StructVector(itr)) == append!!(dest, itr)\n\nholds. Note that the dest argument may or may not be the same object as the returned value.\n\nThe state of dest is unpredictable after append!! is called (e.g., it may contain some, none or all the elements from itr).\n\n\n\n\n\n","category":"function"},{"location":"#StructArrays.replace_storage","page":"StructArrays.jl","title":"StructArrays.replace_storage","text":"StructArrays.replace_storage(f, s::StructArray)\n\nChange storage type for fieldarrays: each array v is replaced by f(v). f(v) is expected to have the sameeltypeandsizeasv`.\n\nExamples\n\nIf PooledArrays is loaded, we can pool all columns of non isbitstype:\n\njulia> using StructArrays, PooledArrays\n\njulia> s = StructArray(a=1:3, b = fill(\"string\", 3));\n\njulia> s_pooled = StructArrays.replace_storage(s) do v\n           isbitstype(eltype(v)) ? v : convert(PooledArray, v)\n       end\n3-element StructArray(::UnitRange{Int64}, ::PooledArray{String,UInt8,1,Array{UInt8,1}}) with eltype NamedTuple{(:a, :b),Tuple{Int64,String}}:\n (a = 1, b = \"string\")\n (a = 2, b = \"string\")\n (a = 3, b = \"string\")\n\n\n\n\n\n","category":"function"},{"location":"#StructArrays.staticschema","page":"StructArrays.jl","title":"StructArrays.staticschema","text":"StructArrays.staticschema(T)\n\nThe default schema for an element type T. A schema is a Tuple or NamedTuple type containing the necessary fields to construct T. By default, this will have fields with the same names and types as T.\n\nThis can be overloaded for custom types if required, in which case StructArrays.createinstance should also be defined.\n\njulia> StructArrays.staticschema(Complex{Float64})\nNamedTuple{(:re, :im),Tuple{Float64,Float64}}\n\n\n\n\n\n","category":"function"},{"location":"#StructArrays.createinstance","page":"StructArrays.jl","title":"StructArrays.createinstance","text":"StructArrays.createinstance(T, args...)\n\nConstruct an instance of type T from its backing representation. args here are the elements of the Tuple or NamedTuple type specified staticschema(T).\n\njulia> StructArrays.createinstance(Complex{Float64}, (re=1.0, im=2.0)...)\n1.0 + 2.0im\n\n\n\n\n\n","category":"function"},{"location":"#Internals","page":"StructArrays.jl","title":"Internals","text":"","category":"section"},{"location":"","page":"StructArrays.jl","title":"StructArrays.jl","text":"StructArrays.get_ith\nStructArrays.map_params\nStructArrays._map_params\nStructArrays.buildfromschema\nStructArrays.bypass_constructor\nStructArrays.iscompatible","category":"page"},{"location":"#StructArrays.get_ith","page":"StructArrays.jl","title":"StructArrays.get_ith","text":"StructArrays.get_ith(cols::Union{Tuple,NamedTuple}, I...)\n\nForm a Tuple of the Ith index of each element of cols, i.e. is equivalent to\n\nmap(c -> c[I...], Tuple(cols))\n\n\n\n\n\n","category":"function"},{"location":"#StructArrays.map_params","page":"StructArrays.jl","title":"StructArrays.map_params","text":"StructArrays.map_params(f, T)\n\nApply f to each field type of Tuple or NamedTuple type T, returning a new Tuple or NamedTuple type.\n\njulia> StructArrays.map_params(T -> Complex{T}, Tuple{Int32,Float64})\nTuple{Complex{Int32},Complex{Float64}}\n\n\n\n\n\n","category":"function"},{"location":"#StructArrays._map_params","page":"StructArrays.jl","title":"StructArrays._map_params","text":"StructArrays._map_params(f, T)\n\nApply f to each field type of Tuple or NamedTuple type T, returning a new Tuple or NamedTuple object.\n\njulia> StructArrays._map_params(T -> Complex{T}, Tuple{Int32,Float64})\n(Complex{Int32}, Complex{Float64})\n\n\n\n\n\n","category":"function"},{"location":"#StructArrays.buildfromschema","page":"StructArrays.jl","title":"StructArrays.buildfromschema","text":"StructArrays.buildfromschema(initializer, T[, S])\n\nConstruct a StructArray{T} with a function initializer, using a schema S.\n\ninitializer(T) is a function applied to each field type of S, and should return an AbstractArray{S}\n\nS is a Tuple or NamedTuple type. The default value is staticschema(T).\n\n\n\n\n\n","category":"function"},{"location":"#StructArrays.bypass_constructor","page":"StructArrays.jl","title":"StructArrays.bypass_constructor","text":"StructArrays.bypass_constructor(T, args)\n\nCreate an instance of type T from a tuple of field values args, bypassing possible internal constructors. T should be a concrete type.\n\n\n\n\n\n","category":"function"},{"location":"#StructArrays.iscompatible","page":"StructArrays.jl","title":"StructArrays.iscompatible","text":"StructArrays.iscompatible(::Type{S}, ::Type{V}) where {S, V<:AbstractArray}\n\nCheck whether element type S can be pushed to a container of type V.\n\n\n\n\n\n","category":"function"}]
}
